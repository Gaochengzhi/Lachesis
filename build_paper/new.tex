
\hypertarget{ux6458ux8981}{%
\subsection{摘要}\label{ux6458ux8981}}

（lambda 演算是什么，有什么特点）

（本文立足于，，，理论，使用。。。开发，，什么效果）

（本文各章的安排）

\hypertarget{ux5f15ux8a00}{%
\subsection{引言}\label{ux5f15ux8a00}}

\hypertarget{ux7814ux7a76ux80ccux666f}{%
\subsubsection{研究背景}\label{ux7814ux7a76ux80ccux666f}}

\hypertarget{section}{%
\subsubsection{}\label{section}}

\hypertarget{ux8ba1ux7b97ux7406ux8bbaux57faux7840}{%
\subsubsection{计算理论基础}\label{ux8ba1ux7b97ux7406ux8bbaux57faux7840}}

\hypertarget{ok}{%
\subsubsection{ok}\label{ok}}

\begin{quote}
如果你想从头做苹果派，你必须先创造宇宙------卡尔萨根（Carl Edward
Sagan，1934年11月9日－1996年12月20日）【1】
\end{quote}

从头制作一门尚未被发明的函数式语言的解释器听起来可比苹果派难多了，

\hypertarget{ux4eceux6700ux62bdux8c61ux5f00ux59cbux4ec0ux4e48ux662fux8ba1ux7b97}{%
\subsubsection{从最抽象开始------什么是计算？}\label{ux4eceux6700ux62bdux8c61ux5f00ux59cbux4ec0ux4e48ux662fux8ba1ux7b97}}

\hypertarget{section-1}{%
\subsubsection{}\label{section-1}}

\hypertarget{lamdba-ux6f14ux7b97}{%
\subsubsection{lamdba 演算}\label{lamdba-ux6f14ux7b97}}

Lambda 演算（也写作\(\lambda\) 演算）是数理逻辑中的一个形式系统（formal
system），用于表达基于函数式抽象模型和变量绑定与替换应用的计算模型。它是一种通用的计算模型（与图灵机等价），由数学家Alonzo
Church 在 1930 年代发明。

Lambda 演算包括：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  构造 lambda 项。
\item
  对它们执行的归约操作（reduction operations）。
\end{enumerate}

在 lambda 演算的最简单形式中，仅使用以下规则构建项：

\begin{longtable}[]{@{}ccc@{}}
\toprule
语法 & 名称 & 描述 \\
\midrule
\endhead
x & 变量 & 标识符名称，用来匹配函数中的某个名字 \\
(\(\lambda\) x.M) & 函数定义 &
x为变量名，M为函数体，函数体默认采用波兰表达式。 \\
MN & 函数应用 & 函数值在参数前面，如(\(\lambda\) x . plus x x) y
=\textgreater{} (plus y y) \\
\bottomrule
\end{longtable}

\hypertarget{ux89e3ux91caux5668ux67b6ux6784ux8bbeux8ba1}{%
\subsection{解释器架构设计}\label{ux89e3ux91caux5668ux67b6ux6784ux8bbeux8ba1}}

\hypertarget{ux7c7bux578bux8bbeux8ba1}{%
\subsubsection{类型设计}\label{ux7c7bux578bux8bbeux8ba1}}

\hypertarget{ux89e3ux91caux5668ux7684ux5de5ux4f5cux6d41ux7a0b}{%
\subsubsection{解释器的工作流程}\label{ux89e3ux91caux5668ux7684ux5de5ux4f5cux6d41ux7a0b}}

\hypertarget{ux6f14ux7b97ux4e0eux5e94ux7528}{%
\paragraph{演算与应用}\label{ux6f14ux7b97ux4e0eux5e94ux7528}}

\hypertarget{ux5de5ux7a0bux5b9eux73b0}{%
\subsection{工程实现}\label{ux5de5ux7a0bux5b9eux73b0}}

\hypertarget{ux505aux597dux51c6ux5907ux5de5ux4f5c}{%
\subsubsection{做好准备工作}\label{ux505aux597dux51c6ux5907ux5de5ux4f5c}}

\hypertarget{vim-ux91cdux6784-vscode}{%
\subsubsection{vim 重构 vscode}\label{vim-ux91cdux6784-vscode}}

\hypertarget{ux4e00ux4e2aux53efux590dux7528ux7684makefile}{%
\subsubsection{一个可复用的Makefile}\label{ux4e00ux4e2aux53efux590dux7528ux7684makefile}}

在中小型的 C/C++ 项目中，一个小巧精干的Makefile 往往比CMake 或 Ninja
更加高效。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{deps }\CharTok{=}\StringTok{ }\CharTok{$(}\KeywordTok{shell}\StringTok{ find  ./src {-}name "*.h"}\CharTok{)}
\DataTypeTok{src }\CharTok{=}\StringTok{ }\CharTok{$(}\KeywordTok{shell}\StringTok{ find  ./lib {-}name "*.c"\&\& find ./src {-}name "*.c"}\CharTok{)}
\DataTypeTok{obj }\CharTok{=}\StringTok{ }\CharTok{$(}\DataTypeTok{src}\KeywordTok{:}\SpecialStringTok{\%.c}\KeywordTok{=}\SpecialStringTok{\%.o}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux52a8ux6001ux8c03ux8bd5ux5668ux6a21ux5f0fux548cux9519ux8befux68c0ux6d4b}{%
\subsubsection{动态调试器模式和错误检测}\label{ux52a8ux6001ux8c03ux8bd5ux5668ux6a21ux5f0fux548cux9519ux8befux68c0ux6d4b}}

在解释器开发和测试过程中，常常因为，其中最常见的是各种内存错误。

现代调试器（如LLDB 或 GDB
等）在捕获内存错误方面的智能化程度非常高。常见的非法内存访问能被快速地定位并给出修改建议，内存泄漏问题更是在编译器就会被提示。

但在捕捉不造成程序异常的语义错误时，往往还需要我们使用最传统的``设置断点------单步跟踪''
法一步一步检查变量赋值情况，这在调试复杂程序时往往显得效率低下。

我们从LLDB 或 GDB
等主流调试器中得到启发，通过向主程序传递命令行参数\texttt{-g}
来开启我们解释器的调试模式：

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ check\_commandline\_argument}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{*}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char}\OperatorTok{**}\NormalTok{ argv}\OperatorTok{)}
\OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \OperatorTok{*}\NormalTok{argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\DecValTok{0}\OperatorTok{]} \OperatorTok{==} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
            \OperatorTok{*}\NormalTok{argc }\OperatorTok{=} \OperatorTok{*}\NormalTok{argc }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{;}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\DecValTok{1}\OperatorTok{]} \OperatorTok{==} \CharTok{\textquotesingle{}g\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                \_debug\_mode }\OperatorTok{=}\NormalTok{ true}\OperatorTok{;}
\NormalTok{                save\_runtime\_info\_to\_log}\OperatorTok{();}
            \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{                puts}\OperatorTok{(}\StringTok{"Invalid option."}\OperatorTok{);}
            \OperatorTok{\}}
            \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ arg\_index }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;}\NormalTok{ arg\_index }\OperatorTok{\textless{}=} \OperatorTok{*}\NormalTok{argc}\OperatorTok{;} \OperatorTok{++}\NormalTok{arg\_index}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                argv}\OperatorTok{[}\NormalTok{arg\_index}\OperatorTok{]} \OperatorTok{=}\NormalTok{ argv}\OperatorTok{[}\NormalTok{arg\_index }\OperatorTok{+} \DecValTok{1}\OperatorTok{];}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

它会修改外部变量\texttt{\_debug\_mode}，使得在主程序中插入的伪多态函数

\hypertarget{ux91cdux6784ux4fddux6301ux8c03ux7406}{%
\subsubsection{重构------保持调理}\label{ux91cdux6784ux4fddux6301ux8c03ux7406}}

\hypertarget{ux6210ux679cux5c55ux793a}{%
\subsection{成果展示}\label{ux6210ux679cux5c55ux793a}}

\hypertarget{ux603bux7ed3ux4e0eux56deux987e}{%
\subsection{总结与回顾}\label{ux603bux7ed3ux4e0eux56deux987e}}

\hypertarget{ux8fdcux79bbux5b8f}{%
\subsubsection{远离宏}\label{ux8fdcux79bbux5b8f}}

目前的智能语义重构器不支持对宏的扫描

\hypertarget{escape-string-vs-unescape-string}{%
\subsubsection{Escape string vs Unescape
string}\label{escape-string-vs-unescape-string}}

\hypertarget{ux81f4ux8c22}{%
\subsection{致谢}\label{ux81f4ux8c22}}

https://en.wikipedia.org/wiki/Computation
https://web.phb123.com/city/renk

66

\hypertarget{ux9644ux5f55}{%
\subsection{附录}\label{ux9644ux5f55}}

\hypertarget{ux58f0ux660e}{%
\subsubsection{声明}\label{ux58f0ux660e}}

\hypertarget{main.c}{%
\subsubsection{main.c}\label{main.c}}

\begin{verbatim}
/**
 * File              : main.c
 * License           : The MIT License (MIT)
 * Author            : Gao Chengzhi <2673730435@qq.com>
 * Date              : 11.02.2022
 * Last Modified Date: 17.02.2022
 * Last Modified By  : Gao Chengzhi <2673730435@qq.com>
 */

#include "../lib/mpc/mpc.h"
#include "headline.h"
#include "lachesis_builtin.h"
#include "lachesis_debug.h"
#include "lachesis_environment.h"
#include "lachesis_object.h"
#include "lachesis_type.h"
#include <readline/history.h>
#include <readline/readline.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

mpc_parser_t* Number;
mpc_parser_t* Symbol;
mpc_parser_t* String;
mpc_parser_t* Comment;
mpc_parser_t* Sexpr;
mpc_parser_t* Qexpr;
mpc_parser_t* Expr;
mpc_parser_t* Lispy;

int main(int argc, char** argv)
{
    /*debug mode switch*/

    check_commandline_argument(&argc, argv);

    Number = mpc_new("number");
    Symbol = mpc_new("symbol");
    String = mpc_new("string");
    Comment = mpc_new("comment");
    Sexpr = mpc_new("sexpr");
    Qexpr = mpc_new("qexpr");
    Expr = mpc_new("expr");
    Lispy = mpc_new("lispy");
    /*Language Definition*/
    mpca_lang(MPCA_LANG_DEFAULT, "                                      \
        number    : /-?[0-9]+/ ;                                        \
        symbol    : /[a-zA-Z0-9_+\\-*\\/\\\\=<>!&]+/;                   \
        string    : /\"(\\\\.|[^\"])*\"/;                               \
        comment   : /;[^\\r\\n]*/;                                      \
        sexpr     : '[' <expr>* ']' ;                                   \
        qexpr     : '{' <expr>* '}' ;                                   \
        expr      : <number> | <symbol> | <string> | <comment>| <sexpr> | <qexpr> ;                     \
        lispy     : /^/ <expr>* /$/ ;                                   \
        ",
        Number, Symbol, String, Comment, Sexpr, Qexpr, Expr,
        Lispy); // notice, can't place space after '\' !

    /*init the environment*/

    lenv* e = lenv_new();
    lenv_builtin_init_list(e);

    if (argc == 1) {

        /*print some welcome words*/
        lec_print_headline();

        while (1) {

            char* input = readline("Lachesis > ");
            /*Attention! readline needs -lreadline argument!*/
            if (strcmp(input, "q") == 0) {
                puts("Bye!");
                exit(0);
            }

            if (strncmp(input, "h ", 2) == 0) {
                print_help(input);
                continue;
            }
            add_history(input);

            mpc_result_t raw;

            if (mpc_parse("<stdin>", input, Lispy, &raw)) {
                LObject* x = lobj_eval(e, lobj_read(raw.output));
                lobj_print_line(x);
                lobj_del(x);
                mpc_ast_delete(raw.output);
            } else {
                mpc_err_print(raw.error);
                mpc_err_delete(raw.error);
            }
            free(input);
        }
    }
    /*file support*/
    if (argc >= 2) {

        for (int i = 1; i < argc; ++i) {

            LObject* args = lobj_add(lobj_sexpr(), lobj_string(argv[i]));

            LObject* x = built_in_load(e, args);

            if (x->type == LOBJ_ERR) {
                lobj_print_line(x);
            }

            lobj_del(x);
        }
    }
    /*before end of code*/
    lenv_del(e);
    mpc_cleanup(7, Number, Symbol, String, Comment, Sexpr, Qexpr, Expr, Lispy);

    return 0;
}
\end{verbatim}
